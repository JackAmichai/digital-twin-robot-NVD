#!/usr/bin/env python3
"""
Integration Tests - End-to-end testing for Digital Twin Robotics Lab.

Tests the complete pipeline:
1. Voice command → ASR → Intent → Redis → ROS 2 → Navigation
2. Service connectivity
3. Data flow validation

Run with: pytest tests/test_integration.py -v
"""

import asyncio
import json
import pytest
import sys
from pathlib import Path
from unittest.mock import Mock, patch, AsyncMock
from datetime import datetime

# Add source directories to path
sys.path.insert(0, str(Path(__file__).parent.parent / "cognitive_service" / "src"))
sys.path.insert(0, str(Path(__file__).parent.parent / "scripts"))


class TestIntentParser:
    """Test the intent parser module."""
    
    def test_fallback_parser_go_to_commands(self):
        """Test fallback parser handles 'go to' commands."""
        from intent_parser import FallbackIntentParser
        
        parser = FallbackIntentParser()
        
        # Test zone commands
        test_cases = [
            ("go to the loading dock", "move_to_zone", "loading_dock"),
            ("move to storage area", "move_to_zone", "storage"),
            ("navigate to charging station", "move_to_zone", "charging"),
            ("head to assembly", "move_to_zone", "assembly"),
        ]
        
        for transcript, expected_action, expected_zone in test_cases:
            intent = parser.parse(transcript)
            assert intent["action"] == expected_action, f"Failed for: {transcript}"
            assert intent["target"] == expected_zone, f"Wrong zone for: {transcript}"
            assert intent["confidence"] > 0.5
    
    def test_fallback_parser_stop_command(self):
        """Test fallback parser handles stop commands."""
        from intent_parser import FallbackIntentParser
        
        parser = FallbackIntentParser()
        
        stop_commands = ["stop", "halt", "emergency stop", "stop now"]
        for cmd in stop_commands:
            intent = parser.parse(cmd)
            assert intent["action"] == "stop"
    
    def test_fallback_parser_status_command(self):
        """Test fallback parser handles status commands."""
        from intent_parser import FallbackIntentParser
        
        parser = FallbackIntentParser()
        
        status_commands = ["what is the status", "report status", "where is the robot"]
        for cmd in status_commands:
            intent = parser.parse(cmd)
            assert intent["action"] == "status"
    
    def test_fallback_parser_unknown_command(self):
        """Test fallback parser returns unknown for gibberish."""
        from intent_parser import FallbackIntentParser
        
        parser = FallbackIntentParser()
        intent = parser.parse("asdfghjkl random words")
        assert intent["action"] == "unknown"
        assert intent["confidence"] < 0.5


class TestZoneCoordinates:
    """Test zone coordinate mappings are consistent."""
    
    def test_zone_coordinates_exist(self):
        """Verify all zones have coordinate mappings."""
        from intent_parser import ZONE_COORDINATES
        
        required_zones = ["loading_dock", "storage", "assembly", "charging", "inspection"]
        for zone in required_zones:
            assert zone in ZONE_COORDINATES, f"Missing zone: {zone}"
            coords = ZONE_COORDINATES[zone]
            assert "x" in coords
            assert "y" in coords
            assert "theta" in coords
    
    def test_zone_coordinates_realistic(self):
        """Verify coordinates are within warehouse bounds."""
        from intent_parser import ZONE_COORDINATES
        
        for zone, coords in ZONE_COORDINATES.items():
            assert -20 <= coords["x"] <= 20, f"X out of bounds for {zone}"
            assert -20 <= coords["y"] <= 20, f"Y out of bounds for {zone}"
            assert -3.15 <= coords["theta"] <= 3.15, f"Theta out of bounds for {zone}"


class TestCommandBridge:
    """Test the command bridge module."""
    
    @pytest.mark.asyncio
    async def test_robot_intent_structure(self):
        """Test RobotIntent JSON structure."""
        from command_bridge import RobotIntent
        
        intent = RobotIntent(
            action="move_to_zone",
            target="loading_dock",
            parameters={"x": 5.0, "y": 2.0, "theta": 0.0},
            confidence=0.95,
            transcript="go to loading dock"
        )
        
        json_str = intent.to_json()
        data = json.loads(json_str)
        
        assert data["action"] == "move_to_zone"
        assert data["target"] == "loading_dock"
        assert data["parameters"]["x"] == 5.0
        assert data["confidence"] == 0.95
        assert "timestamp" in data


class TestHealthMonitor:
    """Test the health monitoring system."""
    
    @pytest.mark.asyncio
    async def test_port_check(self):
        """Test port checking functionality."""
        from health_monitor import HealthMonitor
        
        monitor = HealthMonitor()
        
        # Test a port that should be closed
        is_open, latency = monitor._check_port("localhost", 59999, timeout=0.5)
        assert not is_open
    
    @pytest.mark.asyncio
    async def test_service_health_structure(self):
        """Test ServiceHealth dataclass."""
        from health_monitor import ServiceHealth
        
        health = ServiceHealth(
            name="TestService",
            status="healthy",
            latency_ms=10.5,
            last_check=datetime.now().isoformat(),
            details="All good"
        )
        
        data = health.to_dict()
        assert data["name"] == "TestService"
        assert data["status"] == "healthy"
        assert data["latency_ms"] == 10.5
    
    @pytest.mark.asyncio
    async def test_overall_status_logic(self):
        """Test overall status calculation."""
        from health_monitor import HealthMonitor, ServiceHealth
        
        monitor = HealthMonitor()
        
        # All healthy
        monitor.health_status = {
            "service1": ServiceHealth("s1", "healthy", 10, "", ""),
            "service2": ServiceHealth("s2", "healthy", 10, "", ""),
        }
        assert monitor.get_overall_status() == "healthy"
        
        # One unhealthy
        monitor.health_status["service3"] = ServiceHealth("s3", "unhealthy", 0, "", "")
        assert monitor.get_overall_status() == "degraded"


class TestOrchestrator:
    """Test the system orchestrator."""
    
    @pytest.mark.asyncio
    async def test_orchestrator_initialization(self):
        """Test orchestrator can be created."""
        from orchestrator import SystemOrchestrator
        
        orchestrator = SystemOrchestrator()
        assert orchestrator.redis_host == "localhost"
        assert orchestrator.is_running is False
    
    @pytest.mark.asyncio
    async def test_command_logging(self):
        """Test command log structure."""
        from orchestrator import SystemOrchestrator
        
        orchestrator = SystemOrchestrator()
        
        # Simulate adding a command to log
        test_command = {
            "action": "move_to_zone",
            "target": "storage",
            "timestamp": datetime.now().isoformat()
        }
        orchestrator.command_log.append(test_command)
        
        assert len(orchestrator.command_log) == 1
        assert orchestrator.command_log[0]["action"] == "move_to_zone"


class TestEndToEndPipeline:
    """Test the complete pipeline flow."""
    
    def test_transcript_to_intent_to_coordinates(self):
        """Test full transcript → intent → coordinates pipeline."""
        from intent_parser import FallbackIntentParser, ZONE_COORDINATES
        from command_bridge import RobotIntent
        
        parser = FallbackIntentParser()
        
        # Simulate voice command
        transcript = "robot, go to the storage area please"
        
        # Parse intent
        intent = parser.parse(transcript)
        assert intent["action"] == "move_to_zone"
        assert intent["target"] == "storage"
        
        # Get coordinates
        coords = ZONE_COORDINATES.get(intent["target"], {})
        assert coords["x"] == -5.0
        assert coords["y"] == 2.0
        
        # Create robot intent
        robot_intent = RobotIntent(
            action=intent["action"],
            target=intent["target"],
            parameters=coords,
            confidence=intent["confidence"],
            transcript=transcript
        )
        
        # Verify JSON output
        json_data = json.loads(robot_intent.to_json())
        assert json_data["parameters"]["x"] == -5.0
    
    def test_all_zones_reachable(self):
        """Test all zones can be reached via voice commands."""
        from intent_parser import FallbackIntentParser, ZONE_COORDINATES
        
        parser = FallbackIntentParser()
        
        zone_commands = {
            "loading_dock": "go to loading dock",
            "storage": "navigate to storage",
            "assembly": "move to assembly area",
            "charging": "go to charging station",
            "inspection": "head to inspection",
        }
        
        for zone, command in zone_commands.items():
            intent = parser.parse(command)
            if intent["target"] != zone:
                # Some commands might not match perfectly, that's ok
                continue
            
            assert zone in ZONE_COORDINATES
            coords = ZONE_COORDINATES[zone]
            assert all(k in coords for k in ["x", "y", "theta"])


class TestConfigurationConsistency:
    """Test configuration files are consistent."""
    
    def test_warehouse_zones_match_intent_parser(self):
        """Verify warehouse config zones match intent parser zones."""
        import yaml
        from intent_parser import ZONE_COORDINATES
        
        config_path = Path(__file__).parent.parent / "simulation" / "environments" / "warehouse_config.yaml"
        
        if config_path.exists():
            with open(config_path) as f:
                config = yaml.safe_load(f)
            
            if "zones" in config:
                for zone_name in config["zones"].keys():
                    # Zone names should be consistent
                    normalized = zone_name.lower().replace(" ", "_").replace("-", "_")
                    assert normalized in ZONE_COORDINATES or zone_name in ZONE_COORDINATES, \
                        f"Zone {zone_name} not in intent parser"


# Mock tests for when services aren't available
class TestMockedServices:
    """Tests with mocked external services."""
    
    @pytest.mark.asyncio
    async def test_asr_client_mock(self):
        """Test ASR client with mock."""
        from asr_client import MockASRClient
        
        mock_client = MockASRClient()
        
        transcripts = []
        async for result in mock_client.stream_audio(b"fake_audio"):
            transcripts.append(result.transcript)
        
        assert len(transcripts) > 0
        assert any("robot" in t.lower() for t in transcripts)
    
    @pytest.mark.asyncio
    async def test_redis_mock_pubsub(self):
        """Test Redis pub/sub with mock."""
        # Mock Redis for testing without actual connection
        mock_redis = AsyncMock()
        mock_redis.publish = AsyncMock(return_value=1)
        mock_redis.get = AsyncMock(return_value=None)
        
        # Test publish
        result = await mock_redis.publish("test:channel", "test message")
        assert result == 1
        mock_redis.publish.assert_called_once()


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
